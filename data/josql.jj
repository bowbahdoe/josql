/*
 * Copyright 2004-2005 Gary Bentley 
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may 
 * not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *    http://www.apache.org/licenses/LICENSE-2.0 
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */
options{
    IGNORE_CASE=true ;
    STATIC=false;
    JAVA_UNICODE_ESCAPE=true;
//  DEBUG_LOOKAHEAD= true ;
//  FORCE_LA_CHECK=true;
//  DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(JoSQLParser)

package org.josql.parser;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

import org.josql.Query;

import org.josql.internal.OrderBy;
import org.josql.internal.Limit;
import org.josql.internal.Utilities;
import org.josql.internal.ColumnReference;

import org.josql.expressions.*;

/**
 * The parser generated by JavaCC
 */
public class JoSQLParser {
} 

PARSER_END(JoSQLParser)


SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}

TOKEN: /* SQL Keywords. prefixed with K_ to avoid name clashes */
{
<K_AS: "AS">
|   <K_BY:"BY">
|   <K_IS:"IS">
|   <K_IN:"IN">
|   <K_OR:"OR">
|   <K_ON:"ON">
|   <K_ALL: "ALL">
|   <K_AND: "AND">
|   <K_NOT:"NOT">
|   <K_ASC:"ASC">
|   <K_DESC:"DESC">
|   <K_NULL:"NULL">
|   <K_LIKE:"LIKE">
|   <K_INLIKE:"INLIKE">
|   <K_FROM:"FROM">
|   <K_WHERE:"WHERE">
|   <K_GROUP:"GROUP">
|   <K_LIMIT:"LIMIT">
|   <K_ORDER:"ORDER">
|   <K_SELECT:"SELECT">
|   <K_HAVING:"HAVING">
|   <K_BETWEEN:"BETWEEN">
|   <K_DISTINCT:"DISTINCT">
|   <K_USE: "USE">
|   <K_TRUE: "TRUE">
|   <K_FALSE: "FALSE">
|   <K_EXECUTE: "EXECUTE">
|   <K_RESULTS: "RESULTS">
|   <K_WHERE_RESULTS: "WHERE_RESULTS">
|   <K_HAVING_RESULTS: "HAVING_RESULTS">
|   <K_GROUP_BY_RESULTS: "GROUP_BY_RESULTS">
|   <K_NEW: "new">
|   <K_INTO: "->" >
}

/*
Old Keywords, not really used and prevent use of "value" and "key" as accessors which would be common.
See: http://www.idevelopment.info/data/Programming/java/JavaCC/The_JavaCC_FAQ.htm#tth_sEc4.19
for potential ways of getting around this when these keywords are needed.
|   <K_KEY: "key">
|   <K_VALUE: "value">

*/

TOKEN:
{
	< S_IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: "$" | "_">
| <S_CHAR_LITERAL:
   "'"
   (
         ~["'"]
   )*
   "'"
 >
| <S_CHAR_LITERAL2:
   "\""
   (
         ~["\""]
   )*
   "\""
 >
}

TOKEN : /* Numeric Constants */
{
	< S_DOUBLE: (<S_INTEGER>)? "." <S_INTEGER>  ( ["e","E"] ([ "-","+"])? <S_INTEGER> )? >
  | 	< S_INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >

}


SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"|"//"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">

}

BindVariable BindVariable():
{
  Token t = null;
  BindVariable result = new BindVariable ();
  String prefix = "";
  String acc = null;
}
{

   (":" t = KeywordName() { result.setName (t.image); }
    |
    ":_" t = <S_IDENTIFIER> { prefix = "_";  result.setName (prefix + t.image); } 
    |
    "?" { result.setAnonymous (true); } 
   )
   [ "." acc = Name() { result.setAccessor (acc); } ]
   {
      return result;
   }

}

SaveValue SaveValue():
{
  Token t = null;
  SaveValue result = new SaveValue ();
  String v = null;
  String acc = null;
}
{

   "@" t = KeywordName() [ "." acc = Name() { result.setAccessor (acc); } ]
   {

      result.setName (t.image);

      return result;
   }

}

void parseQuery(Query q):
{
}
{
    Query(q)
    [";"]
    <EOF>
}

String Name():
{

  StringBuffer v = new StringBuffer ();
  Token val = null;
  
}
{

  // Is in form... name.name.name
   val =  KeywordName() { v.append (val.image); }
  ( "." { v.append ("."); } 
    val = KeywordName() { v.append (val.image); }
  )*
  {

     return v.toString ();

  }

} 

Token KeywordName():
{

  Token t = null;

}
{

   ( t = <K_AS>
|  t = <K_BY>
|  t = <K_IS>
|  t = <K_IN>
|  t = <K_OR>
|  t = <K_ON>
|  t = <K_ALL>
|  t = <K_AND>
|  t = <K_NOT>
|  t = <K_ASC>
|  t = <K_DESC>
|  t = <K_LIKE>
|  t = <K_INLIKE>
/*|  t = <K_FROM>*/
|  t = <K_WHERE>
|  t = <K_GROUP>
|  t = <K_LIMIT>
|  t = <K_ORDER>
|  t = <K_SELECT>
|  t = <K_DISTINCT>
|  t = <K_NEW>
|  t = <K_TRUE>
|  t = <K_FALSE>
|  t = <K_HAVING>
|  t = <K_BETWEEN>
|  t = <K_USE>
|  t = <K_EXECUTE>
|  t = <K_RESULTS>
|  t = <K_WHERE_RESULTS>
|  t = <K_HAVING_RESULTS>
|  t = <K_GROUP_BY_RESULTS>
|  t = <S_IDENTIFIER> )
{
  return t;
}

}

/*
String MultiName():
{

  StringBuffer v = new StringBuffer ();
  Token val = null;
  
}
{

  // Is in form... name[name.name]
  val = Name()
  [ "[" [ <K_KEY> | <K_VALUE> ] val = PrimaryExpression() "]" { v.append (val.image); } ]
  {

     return v.toString ();

  }

} 
*/

String RelObjectName():
{	Token tk = null; }
{
	(
	tk=KeywordName()
	|
	tk=<S_CHAR_LITERAL>
	|
	tk=<S_CHAR_LITERAL2>
	)
	
    { return tk.image; }
}

void Query(Query q):
{ 
	List cols = null;
	List fromItems = null;
	List joins = null;
	Expression where = null;
	List orderBys = null;
	List groupOrderBys = null;
	List groupBys = null;
	Expression having = null;
	Limit limit = null;
        Limit grpLimit = null;
        Expression from = null;
        Map execute = null;
        boolean distinct = false;
}
{
    <K_SELECT>  [ LOOKAHEAD(2) <K_DISTINCT> { q.setWantDistinctResults (true); } ]
    cols = SelectItemsList(q)
    from = From() 
    [ where = WhereClause() ]
    [ LOOKAHEAD(2) groupBys = GroupBys() ]
    [ having = Having() ]
    [ LOOKAHEAD(GroupOrderBys()) groupOrderBys = GroupOrderBys() ]
    [ orderBys = OrderBys() ]
    [ LOOKAHEAD(GroupLimit()) grpLimit = GroupLimit() ]
    [ limit = Limit() ]
    [ execute = ExecuteOn() ]

    { 
      // We set all the values since they are all dependent on the class 
      // being available.
      q.setFrom (from); 
      q.setColumns (cols);
      q.setWhere (where);
      q.setHaving (having);
      q.setGroupByOrderColumns (groupOrderBys);
      q.setOrderByColumns (orderBys);
      q.setGroupByColumns (groupBys);
      q.setGroupByLimit (grpLimit);
      q.setLimit (limit);
      q.setExecuteOnFunctions (execute);

    }
}

Map ExecuteOn():
{

   Map et = new HashMap ();

}
{

   (<K_EXECUTE> <K_ON> et = ExecuteOnType(et))+
   {

      return et;

   }

}

Map ExecuteOnType(Map execOn):
{

   List el = null;
   String type = null;

}
{

   (<K_ALL> { type = Query.ALL; }
    |
    <K_RESULTS> { type = Query.RESULTS; }
    |
    <K_WHERE_RESULTS> { type = Query.RESULTS; }
    |
    <K_HAVING_RESULTS> { type = Query.HAVING_RESULTS; }
    |
    <K_GROUP_BY_RESULTS> { type = Query.GROUP_BY_RESULTS; }
   )
   el = AliasedSQLExpressionList()
   {

      List fs = (List) execOn.get (type);

      if (fs != null)
      {

         fs.addAll (el);

      } else {

         execOn.put (type,
                     el);

      }

   }
   {

      return execOn;

   }

}

List SelectItemsList(Query q):
{ 
	List selectItemsList = new ArrayList();
        SelectItemExpression si = null;
}
{ 
    si = SelectItem(q) { if (si != null) { selectItemsList.add (si); } } ("," si = SelectItem(q) { if (si != null) { selectItemsList.add (si); }} )*
    
    { return selectItemsList; }
}

List FunctionList():
{ 
	List fList = new ArrayList();
        AliasedFunction f = null;
        String alias = null;
}
{ 
    f = AliasedFunction() { fList.add (f); } ("," f = AliasedFunction() { fList.add (f); } )*
    
    { return fList; }
}

AliasedFunction AliasedFunction():
{

   AliasedFunction af = new AliasedFunction ();
   String alias = null;
   Function f = null;

}
{

   (f = Function() [ alias = Alias() ])
   {

      af.setAlias (alias);
      af.setExpression (f);      

      return af;

   }

}

SelectItemExpression SelectItem(Query q):
{
	String alias = null;
	SelectItemExpression csei = null;
	Expression expression = null;
        boolean addItemsFromColl = false;
        Token addItemType = null;
}
{
    ( "*" { q.setWantObjects (true); return null; }
    |
    
    /*
    OLD
    [ "[" "*" [ "," addItemType = <S_IDENTIFIER> ] "]" { addItemsFromColl = true; } ] expression = OrExpression() { csei = new SelectItemExpression (); csei.setExpression (expression); }    
    */    
    [ LOOKAHEAD(2) "[" "*" [ "," addItemType = KeywordName() ] "]" { addItemsFromColl = true; } ] expression = ExpressionList() { csei = new SelectItemExpression (); csei.setExpression (expression); }
	 [ LOOKAHEAD(2) alias=Alias() { csei.setAlias (alias); }
    ] 
	)
	{

            if (addItemsFromColl)
            {

               csei.setAddItemsType (java.util.Collection.class);

  	       if (addItemType != null)
               {

                  csei.setAddMapType (addItemType.image);
                  csei.setAddItemsType (java.util.Map.class);

               }

            }

            return csei;

	}
	
}

NewObjectExpression NewObjectExpression():
{
   String setterName = null;
   String className = null;
   List conArgs = null;
   Expression expression = null;

   NewObjectExpression noe = new NewObjectExpression ();

}
{

  <K_NEW> { noe = new NewObjectExpression (); } className = Name() { noe.setClassName (className); } "(" [ conArgs = SQLExpressionList() { noe.setConstructorArgs (conArgs); } ] ")"
      [ "{" expression = ExpressionList() "->" setterName = Name() { noe.addIntoExpression (expression, setterName); }
          ( "," expression = ExpressionList() "->" setterName = Name() { noe.addIntoExpression (expression, setterName); }
          )*
        "}" 
      ]
   {

      return noe;

   }

}

String Alias():
{ String retval = null; }
{
	[LOOKAHEAD(2) <K_AS>] retval=RelObjectName()
   { return retval; }
}

Expression From():
{
   String cn = null;
   Expression from = null;
}
{
    <K_FROM> 
    (from = BindVariable ()
     | 
     from = SaveValue ()
     |
     LOOKAHEAD(3) 
     ( <K_NULL> { cn = "null"; }
       |
       cn = Name()
     )
     { ConstantExpression ce = new ConstantExpression (); from = ce; ce.setValue (cn); }
     |
     LOOKAHEAD(3) from = Function ()
    )
    {
      return from;
    }
}

Expression WhereClause():
{
	Expression retval = null;
}
{
    <K_WHERE> retval = ExpressionList() 
    { return retval; }
}


List GroupBys():
{
	List groupBys = new ArrayList();
        OrderBy ob = null;
}
{

    <K_GROUP> <K_BY> ob = OrderBy() { groupBys.add (ob); }
        ("," ob = OrderBy() { groupBys.add (ob); } )*
    {
    	return groupBys; 	
    }

}

Expression Having():
{
	Expression having = null;
}
{
    <K_HAVING> having = ExpressionList()
	{
		return having;
	}
}

List OrderBys():
{ 
   List orderBys = new ArrayList ();
   OrderBy ob = null;
}
{
    <K_ORDER> <K_BY> ob = OrderBy() { orderBys.add (ob); }
        ("," ob = OrderBy() { orderBys.add (ob); } )*
    {
    	return orderBys; 	
    }
}

List GroupOrderBys():
{ 
   List orderBys = new ArrayList ();
   OrderBy ob = null;
}
{
    <K_GROUP> <K_BY> <K_ORDER> ob = OrderBy() { orderBys.add (ob); }
        ("," ob = OrderBy() { orderBys.add (ob); } )*
    {
    	return orderBys; 	
    }
}

OrderBy OrderBy():
{
   OrderBy oe = new OrderBy (); 
   String acc = null;
   Token ci = null;
   int cInt = -1;
   Expression exp = null;
   
}
{

    (LOOKAHEAD(2) ci = <S_INTEGER> { cInt = Integer.parseInt (ci.image); oe.setIndex (cInt); }
    |
    exp = ExpressionList() { oe.setExpression (exp); } )
    [<K_ASC> { oe.setType (OrderBy.ASC); } | <K_DESC> { oe.setType (OrderBy.DESC); }  ]
   {

      return oe;

   }

}

Limit Limit():
{
	Limit limit = new Limit (); 
	Token token = null;
        Expression start = null;
        Expression rows = null;
}
{
   <K_LIMIT> [ LOOKAHEAD(2) start = SimpleExpression() "," ] rows = SimpleExpression()
   {

      if ((start != null)
          &&
          (!(start instanceof ValueExpression))
         )
      {

         throw new ParseException ("Only expressions that return a numeric value are supported as the start value for the LIMIT part of the query.");

      }

      if (!(rows instanceof ValueExpression))
      {

         throw new ParseException ("Only expressions that return a numeric value are supported as the rows value for the LIMIT part of the query.");

      }

      limit.setStart ((ValueExpression) start);
      limit.setRowsCount ((ValueExpression) rows);

      return limit;

   }
}

Limit GroupLimit():
{
	Limit limit = new Limit (); 
	Token token = null;
        Expression start = null;
        Expression rows = null;
}
{
   <K_GROUP> <K_BY> <K_LIMIT> [ LOOKAHEAD(2) start = SimpleExpression() "," ] rows = SimpleExpression()
   {

      if ((start != null)
          &&
          (!(start instanceof ValueExpression))
         )
      {

         throw new ParseException ("Only expressions that return a numeric value are supported as the start value for the LIMIT part of the query.");

      }

      if (!(rows instanceof ValueExpression))
      {

         throw new ParseException ("Only expressions that return a numeric value are supported as the rows value for the LIMIT part of the query.");

      }

      limit.setStart ((ValueExpression) start);
      limit.setRowsCount ((ValueExpression) rows);

      return limit;

   }
}

ColumnReference ColumnReference():
{
	ColumnReference retval = new ColumnReference ();
        String name = null;
        int index = -1;
}
{
	(name = Name() { retval.setName (name); }
         | index = ColumnIndex() { retval.setIndex (index); }
        )
	{
          return retval;
	}
}

int ColumnIndex(): 
{
   Token index = null;

}
{
	index=<S_INTEGER>
	{
	   return Integer.parseInt(index.image);
	}
}

Expression ExpressionList():
{

   ExpressionList el = null;
   Expression expr = null;

}
{

    expr = OrExpression() { return expr; }
    |
    "[" expr = ExpressionList() { el = new ExpressionList (); el.addExpression (expr); }
    ( "," expr = ExpressionList() { el.addExpression (expr); } )*
    "]"
    {
    
        return el;
    
    }

}

Expression OrExpression():
{
	Expression left;
        Expression right;
        Expression result;
}
{
	left = AndExpression () { result = left; }
	(
		LOOKAHEAD(<K_OR>) 
			<K_OR>
			right = ExpressionList()
			{
				result = new AndOrExpression ();
                                BinaryExpression be = (BinaryExpression) result;
                                be.setLeft (left);
                                be.setRight (right);

	   		}
	 )*
	 {
	 	return result;
	 }
	   
}

Expression AndExpression() :
{
	Expression left;
        Expression right;
        Expression result;
}
{
	left = Condition() { result = left; }
	(
		LOOKAHEAD(<K_AND>)
		<K_AND>
		right = ExpressionList()
		{

			result = new AndOrExpression ();

                        AndOrExpression aoe = (AndOrExpression) result;
                        aoe.setLeft (left);
                        aoe.setRight (right);
                        aoe.setAnd (true);

		}
	)* 
	{
	  return result;
	}
}

Expression Condition():
{
	Expression result;
}
{
	(LOOKAHEAD(SQLCondition()) result = SQLCondition()
	| result = RegularCondition())
	
	{ return result; }
}

Expression RegularCondition():
{
	Expression result = null;
	Expression left = null;
	Expression right = null;
        boolean ignoreCase = false;
}
{
	left = SimpleExpression() { result = left; }
        [

          // Allows $ before any of the following.
          ["$" { ignoreCase = true; } ]  
          (
           ">" { result = new GTLTExpression (); GTLTExpression lt = (GTLTExpression) result; lt.setIgnoreCase (ignoreCase); lt.setType (Utilities.GT); }
	   | "<" { result = new GTLTExpression (); lt = (GTLTExpression) result; lt.setIgnoreCase (ignoreCase); lt.setType (Utilities.LT); }
	   | "=" { result = new EqualsExpression (); EqualsExpression ee = (EqualsExpression) result; ee.setIgnoreCase (ignoreCase); }
	   | ">=" { result = new GTLTExpression (); lt = (GTLTExpression) result; lt.setIgnoreCase (ignoreCase); lt.setType (Utilities.GTE); }
	   | "<=" { result = new GTLTExpression (); lt = (GTLTExpression) result; lt.setIgnoreCase (ignoreCase); lt.setType (Utilities.LTE); }
	   | ("<>" | "!=") { result = new EqualsExpression (); ee = (EqualsExpression) result; ee.setNot (true); ee.setIgnoreCase (ignoreCase); }
	  )
		right = SimpleExpression()
	{ BinaryExpression be = (BinaryExpression) result;
          be.setLeft (left);
          be.setRight (right);
 
        }
        ]

     {
       return result;
     }
}


Expression SQLCondition():
{
	Expression result;
}
{
	(
	LOOKAHEAD(InExpression()) result = InExpression ()
	| LOOKAHEAD(BetweenExpression()) result = BetweenExpression ()
	| LOOKAHEAD(IsNullExpression()) result = IsNullExpression ()
	|  result = LikeExpression ()
	)
	{ return result; }
}

InExpression InExpression():
{
	InExpression result = new InExpression();
	List items = null;
	Expression left = null;
}
{
	left = SimpleExpression()
    [<K_NOT> { result.setNot(true); } ] [ "$" { result.setIgnoreCase (true); } ] <K_IN> [ "$" { result.setIgnoreCase (true); } ] [ <K_LIKE> { result.setDoLike (true); } ] [ <K_ALL>  { result.setAll (true); } ] "(" items = SQLExpressionList() ")"
	{ 

           if (!(left instanceof ValueExpression))
           {

              throw new ParseException ("The left-hand side of an [NOT] IN clause must be a value expression.");

           }

	   result.setLeft ((ValueExpression) left);

           for (int i = 0; i < items.size (); i++)
           {

              if (!(items.get (i) instanceof ValueExpression))
              {

                 throw new ParseException ("Item: " + (i + 1) + " from the [NOT] IN clause is NOT a value expression, is: \"" + items.get (i).toString () + "\"");

              }

           }

           result.setItems (items);
	   return result; 

	}

}

BetweenExpression BetweenExpression():
{
	BetweenExpression result = new BetweenExpression ();
	Expression left = null;
	Expression start = null;
	Expression end = null;
}
{
	left = SimpleExpression()
	    [<K_NOT> { result.setNot(true); }] 
	    <K_BETWEEN> start = SimpleExpression() <K_AND> end = SimpleExpression()
	
	{ 

           if (!(left instanceof ValueExpression))
           {

              throw new ParseException ("The left-hand side of an [NOT] BETWEEN clause must be a value expression, is: \"" + left + "\"");

           }

           if (!(start instanceof ValueExpression))
           {

              throw new ParseException ("The START value of an [NOT] BETWEEN clause must be a value expression, is: \"" + start + "\"");

           }

           if (!(end instanceof ValueExpression))
           {

              throw new ParseException ("The END value of an [NOT] BETWEEN clause must be a value expression, is: \"" + end + "\"");

           }

		result.setLeft ((ValueExpression) left);
		result.setStart ((ValueExpression) start);
		result.setEnd ((ValueExpression) end);
		return result; 
	}
}

LikeExpression LikeExpression() :
{
	LikeExpression result = new LikeExpression ();
	Expression left = null;
	Expression right = null;
}
{
	left = SimpleExpression()
    [<K_NOT> { result.setNot (true); } ] [ "$" { result.setIgnoreCase (true); } ] <K_LIKE> right = SimpleExpression()
    
	{ 
		result.setLeft (left);
		result.setRight (right);
		return result; 
	}
}

IsNullExpression IsNullExpression():
{
	IsNullExpression result = new IsNullExpression ();
	Expression left = null;
}
{
	left = SimpleExpression()
    <K_IS> [<K_NOT> { result.setNot (true); } ] <K_NULL>

	{ 
		result.setLeft (left);
		return result; 
	}
}


List SQLExpressionList():
{
	List expressions = new ArrayList();
	Expression expr = null;
        ExpressionList eList = null;
        List exprList = null;

}
{
    expr = ExpressionList() { expressions.add(expr); } ("," expr = ExpressionList() { expressions.add(expr); })*
	{
		return expressions;
	}

}

List AliasedSQLExpressionList():
{
	List expressions = new ArrayList();
	AliasedExpression aexp = null;
	Expression expr = null;
        String alias = null;

}
{
    expr = ExpressionList() { aexp = new AliasedExpression (); aexp.setExpression (expr); expressions.add (aexp); } [ LOOKAHEAD(2) alias = Alias() { aexp.setAlias (alias); } ] ("," expr = ExpressionList() { aexp = new AliasedExpression (); aexp.setExpression (expr); expressions.add (aexp); } [ LOOKAHEAD(2) alias = Alias() { aexp.setAlias (alias); } ] )*
	{
		return expressions;
	}

}

Expression SimpleExpression():
{
	Expression result = null;
}
{
    (LOOKAHEAD(3) result = AdditiveExpression()
     |
     LOOKAHEAD(3) result = MultiplicativeExpression()
     |
     LOOKAHEAD(3) result = PrimaryExpression()
    )
    {
    	return result;
    }
}

Expression AdditiveExpression():
{
	Expression result = null;
	Expression left = null;
	Expression right = null;
        int type = -1;
}
{
    left = MultiplicativeExpression()  { result = left; }
    (
    	LOOKAHEAD(2) ("+" { type = ArithmeticExpression.ADDITION; }
    	            | "-" { type = ArithmeticExpression.SUBTRACT; }
                     ) 
		right = AdditiveExpression()
    						
		{

           if (!(left instanceof ValueExpression))
           {

              throw new ParseException ("The left-hand side of an arithmetic expresion (+, -, *, / or %) must be a value expression.");

           }

           if (!(right instanceof ValueExpression))
           {

              throw new ParseException ("The right-hand side of an arithmetic expresion (+, -, *, / or %) must be a value expression.");

           }

                  ArithmeticExpression ae = new ArithmeticExpression ();
		  ae.setLeft ((ValueExpression) left);
	          ae.setRight ((ValueExpression) right);
                  result = ae;
                  ae.setType (type);

		}								
    )*
    
    { return result; }
}

Expression MultiplicativeExpression():
{
	Expression result = null;
	Expression left = null;
	Expression right = null;
        int type = -1;
}
{
    left = PrimaryExpression()  { result = left; }
    (
    	LOOKAHEAD(2) ("*" { type = ArithmeticExpression.MULTIPLY; }
 		     | "/" { type = ArithmeticExpression.DIVIDE; }  
 		     | "%" { type = ArithmeticExpression.MODULUS; } 
                     ) 
		  right = AdditiveExpression()
    						
		{
           if (!(left instanceof ValueExpression))
           {

              throw new ParseException ("The left-hand side of an arithmetic expresion (+, -, *, / or %) must be a value expression.");

           }

           if (!(right instanceof ValueExpression))
           {

              throw new ParseException ("The right-hand side of an arithmetic expresion (+, -, *, / or %) must be a value expression.");

           }

                  ArithmeticExpression ae = new ArithmeticExpression ();
		  ae.setLeft ((ValueExpression) left);
	          ae.setRight ((ValueExpression) right);
                  result = ae;
                  ae.setType (type);

		}								
    )*
    { return result; }
}

Expression PrimaryExpression():
{ 
	Expression retval = null;
	Token token = null;
	boolean isInverse = false;
	String tmp = "";
        String accName = null;
}
{

(
        LOOKAHEAD(2) retval = NewObjectExpression()
        | LOOKAHEAD(2) retval = SubQueryExpression()
	| <K_NULL> { retval = new ConstantExpression (); ConstantExpression ce = (ConstantExpression) retval; ce.setValue (null); }
        | LOOKAHEAD(2) <K_TRUE> { retval = new BooleanExpression (); BooleanExpression be = (BooleanExpression) retval; be.setValue (Boolean.TRUE); }
        | LOOKAHEAD(2) <K_FALSE> { retval = new BooleanExpression (); BooleanExpression be = (BooleanExpression) retval; be.setValue (Boolean.FALSE); }
        | retval = BindVariable()
        | retval = SaveValue()
	|    LOOKAHEAD([ "+" | "-"] Function()) [ "+" | "-" { isInverse = true; }] retval = Function() 
	
	| LOOKAHEAD([	"+" | "-"] <S_DOUBLE>) 	[	"+" | "-" { tmp = "-"; }]  token=<S_DOUBLE> { retval = new ConstantExpression (); ce = (ConstantExpression) retval; ce.setValue (new Double (tmp+token.image)); }
	
	| LOOKAHEAD([	"+" | "-"] <S_INTEGER>)  	[	"+" | "-" { tmp = "-"; }]  token=<S_INTEGER> { retval = new ConstantExpression (); ce = (ConstantExpression) retval; ce.setValue (new Double (tmp+token.image)); }

	| LOOKAHEAD(2) 	[ "+" | "-" { isInverse = true; }] accName = Name() {retval= new Accessor (); Accessor a = (Accessor) retval; a.setAccessor (accName); }

/*
	| LOOKAHEAD(2) 	[ "+" | "-" { isInverse = true; }] accName = MultiName() {retval= new MultiAccessor (); MultiAccessor a = (MultiAccessor) retval; a.setAccessor (accName); }
*/

	| LOOKAHEAD(2) [ "+" | "-" { isInverse = true; }]  "(" retval = ExpressionList() ")" { retval.setBracketed (true); }

	| token=<S_CHAR_LITERAL> { retval = new ConstantExpression (); ce = (ConstantExpression) retval; ce.setValue (token.image.substring (1,token.image.length () - 1)); }
	| token=<S_CHAR_LITERAL2> { retval = new ConstantExpression (); ce = (ConstantExpression) retval; ce.setValue (token.image.substring (1,token.image.length () - 1)); }

)
    { 
    	return retval; 
    }
}

Function Function():
{
	Function retval = new Function ();
	String funcName = null;
	String tmp = null;
	List params = null;
        String acc = null;
}
{
    funcName = Name() 
    "(" [ (params = SQLExpressionList()) ] ")"
    [ "." acc = Name() ]
    { 
	    retval.setParameters (params);
	    retval.setName (funcName);
            retval.setAccessor (acc);
       	    return retval; 
    }

}

SubQueryExpression SubQueryExpression ():
{ 
    Query q = new Query ();
    SubQueryExpression exp = new SubQueryExpression (q);
    String acc = null;
}
{
    "(" Query(q) ")" [ "." acc = Name() { exp.setAccessor (acc); } ]
    {
 
      return exp;

    }
}

